# Упражнения: Класови атрибути (Class Attributes)

---

### Задача 1 — Базова (лесна)
Създайте клас `Person` с инстанционни атрибути `name` и `age`. Добавете класов атрибут `species = 'Homo sapiens'`. Направете пример с две инстанции и отпечатайте `name`, `age` и `species`.

Критерии за приемане:
- Класът има `__init__(self, name, age)`
- Има класов атрибут `species`
- Примерът отпечатва правилни стойности

---

### Задача 2 — Дефолтна стойност чрез класов атрибут
Създайте клас `Book` с инстанционни атрибути `title` и `author`. Ако не е посочен език в `__init__`, използвайте класов атрибут `default_language = 'EN'` като стойност по подразбиране.

Критерии:
- Ако създадем `Book('Hamlet', 'Shakespeare')`, езикът е `EN`.
- Ако подадем език в `__init__`, да се използва той.

Подсказка: в `__init__` използвайте аргумент `language=None` и ако е `None` то `self.language = self.__class__.default_language`.

---

### Задача 3 — Капан с mutable класов атрибут
Създайте клас `Team` с класов атрибут `members = []`. Създайте две инстанции и добавете различни членове чрез `team.members.append(...)`. Обяснете защо това е проблем и пренапишете класа така, че всеки обект да има собствен `members` списък.

Критерии:
- Демонстрация на проблема (след добавяне в `t1` и `t2` двата списъка стават общи)
- Решение: инициализация на `self.members = []` в `__init__`

---

### Задача 4 — Брояч на инстанции
Създайте клас `User` с класов атрибут `count = 0`. Всеки път, когато се създава инстанция, увеличавайте `count`. Добавете класов метод `@classmethod def get_count(cls):` който връща броя.

Критерии:
- Създаването на 3 инстанции води `User.count` да бъде 3
- `User.get_count()` връща същата стойност

---

### Задача 5 — Промяна на класов атрибут чрез `@classmethod`
Създайте клас `Config` с класов атрибут `debug = False`. Добавете `@classmethod enable_debug(cls)` и `@classmethod disable_debug(cls)` за промяна. Демонстрирайте, че промяната през класа засяга всички инстанции.

Критерии:
- `Config.enable_debug()` задава `Config.debug` на `True`
- Инстанциите виждат промяната

---

### Задача 6 — Наследяване и класови атрибути
Създайте базов клас `Animal` с класов атрибут `sound = ''`. Направете два подкласа `Dog` и `Cat` с различни `sound` стойности. Добавете метод `speak(self)` който връща `self.sound`.

Критерии:
- `Dog().speak()` връща стойността зададена в `Dog` и не променя `Animal.sound`

---

### Задача 7 — `abc` + класов атрибут изискване (средно-трудна)
Създайте абстрактен базов клас `Vehicle` (използвайте `abc.ABC`) с класов атрибут `wheels = None`. Изисквайте от подкласовете да зададат `wheels` и да имплементират абстрактен метод `drive(self)`. Демонстрирайте `TypeError`, ако подклас не зададе `wheels` или не имплементира `drive`.

Критерии:
- `Vehicle` е абстрактен
- Подклас, който не зададе `wheels` или `drive`, не може да бъде инстанциран

Подсказка: може да валидирате в `__init_subclass__` че `cls.wheels` не е `None`.

---

### Задача 8 — `@property` използващ класов атрибут
Създайте клас `Product` с класов атрибут `tax_rate = 0.2`. В `__init__` подавайте `price`. Добавете `@property def price_with_tax(self)` който използва `self.__class__.tax_rate`.

Критерии:
- Промяна на `Product.tax_rate` да променя резултата за всички инстанции
- Може да се зададе различен tax_rate в подклас (например `Food`) и да се вижда различна стойност

---

### Задача 9 — Регистър на подкласове с `__init_subclass__` (трудна)
Създайте базов клас `Plugin` с класов атрибут `registry = {}`. Всеки път когато се дефинира подклас, `Plugin` автоматично регистрира подкласите в `registry` чрез `__init_subclass__`, например `registry['името_на_подклас'] = подклас`. Добавете метод `list_plugins()` за изброяване.

Критерии:
- След дефиниране на няколко подкласа, `Plugin.registry` съдържа всички подкласи
- `Plugin.list_plugins()` връща списък от имена

Подсказка: използвайте `cls.__name__` и `super().__init_subclass__(**kwargs)`

---

### Задача 10 — Комбинирана (много трудна)
Създайте система от класове за управление на връзки към база данни (симулирана). Задани изисквания:

1. Има базов клас `ConnectionPool` с класов атрибут `_pools = {}` (регистър на пулове по име).
2. Конструкторът приема `name` и `max_size` (инстанционни атрибути). Ако пул с дадено `name` вече съществува в `_pools`, връща съществуващия пул (т.е. пулът се споделя между инстанции с едно и също име).
3. Имплементирайте `acquire()` и `release()` методи симулиращи вземане и връщане на връзка (може да е просто число). Състоянието на пуловете трябва да бъде споделено чрез класовия атрибут `_pools`.
4. Използвайте `@property` за `size` който връща текущия брой активни връзки в този пул.
5. Напишете кратък тест/демонстрация, където няколко „инстанции“ с едно и също име споделят един пул.

Критерии:
- `_pools` е класов атрибут и съдържа данните за всеки пул
- Създаването на два `ConnectionPool('main', 10)` обекта не създава двоен независим пул
- `acquire`/`release` работят и `size` отразява състоянието

Подсказка: не е нужно да използвате истински DB връзки — използвайте прости IDs и списъци. Помислете за thread-safety ако искате допълнително сложност (опция).

---