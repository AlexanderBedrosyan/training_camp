# SQL Лекция 3: Функции, Wildcards и Работа с Текст и Числа

Добре дошли в третата стъпка от работата с бази данни!

В предишните лекции научихме как се **създават таблици** (`CREATE TABLE`), как се **добавят данни** (`INSERT INTO`) и как да **четем**, **филтрираме**, **обновяваме** и **изтриваме** данни (`SELECT`, `WHERE`, `UPDATE`, `DELETE`, `ORDER BY`, `LIMIT`). В тази лекция ще разгледаме **вградените SQL функции** — мощни инструменти, с които можем да трансформираме и изчисляваме данни директно в заявката.

---

## Подготовка: Нашата тестова таблица

Преди да започнем, нека имаме готова таблица с данни. Изпълнете следното:

```sql
CREATE TABLE IF NOT EXISTS employees (
    id        INTEGER PRIMARY KEY,
    name      TEXT,
    position  TEXT,
    salary    REAL,
    hire_date TEXT
);

INSERT INTO employees (name, position, salary, hire_date) VALUES ('Ivan Petrov',     'Software Engineer', 4500.50, '2021-03-15');
INSERT INTO employees (name, position, salary, hire_date) VALUES ('Maria Ivanova',   'Designer',          3800.00, '2020-07-01');
INSERT INTO employees (name, position, salary, hire_date) VALUES ('Georgi Dimitrov', 'Team Lead',         6200.00, '2019-11-20');
INSERT INTO employees (name, position, salary, hire_date) VALUES ('Elena Stoyanova', 'QA Engineer',       4100.00, '2022-01-10');
INSERT INTO employees (name, position, salary, hire_date) VALUES ('Nikolay Todorov', 'Software Engineer', 4500.50, '2021-09-05');
INSERT INTO employees (name, position, salary, hire_date) VALUES ('Petya Koeva',     'Designer',          3600.75, '2023-04-18');
INSERT INTO employees (name, position, salary, hire_date) VALUES ('Stefan Boev',     'DevOps Engineer',   5100.00, '2020-02-28');
```

> **Важно:** Ако вече имате таблица `employees` от предишна лекция, изпълнете `DROP TABLE employees;` първо, след което горните заявки. В тази лекция добавяме нова колона `hire_date` за дата на наемане.

---

## 1. Функции в SQL — Въведение

SQL предоставя голям брой **вградени функции** (built-in functions), които ни позволяват да:
- Обработваме текстови данни (да ги трансформираме, разрязваме, заместваме)
- Извършваме математически изчисления (закръгляне, абсолютна стойност)
- Работим с дати и часове (извличане на година, месец, ден)

Функциите се извикват директно в `SELECT` заявката и работят **ред по ред** — за всеки ред в таблицата функцията се прилага върху стойността в съответната колона.

### Синтаксис (общ)

```sql
SELECT ФУНКЦИЯ(колона) FROM таблица;
```

Или с условие:

```sql
SELECT ФУНКЦИЯ(колона) FROM таблица WHERE условие;
```

---

## 2. Текстови функции (String Functions)

Текстовите функции ни позволяват да трансформираме и анализираме текстови стойности.

---

### 2.1 UPPER() и LOWER() — Промяна на регистъра

`UPPER()` преобразува текст в **ГЛАВНИ БУКВИ**, а `LOWER()` — в **малки букви**.

```sql
-- Всички имена с главни букви
SELECT UPPER(name) AS name_upper FROM employees;
```

| name_upper       |
|------------------|
| IVAN PETROV      |
| MARIA IVANOVA    |
| GEORGI DIMITROV  |
| ...              |

```sql
-- Всички длъжности с малки букви
SELECT LOWER(position) AS position_lower FROM employees;
```

> **Кога се използва?** Когато искате да сравнявате текст без значение на регистъра, например `WHERE LOWER(name) = 'ivan petrov'`.

---

### 2.2 LENGTH() — Дължина на текста

`LENGTH()` връща **броя символи** в текстова стойност.

```sql
SELECT name, LENGTH(name) AS name_length FROM employees;
```

| name             | name_length |
|------------------|-------------|
| Ivan Petrov      | 11          |
| Maria Ivanova    | 13          |
| Georgi Dimitrov  | 16          |
| ...              | ...         |

---

### 2.3 SUBSTR() — Извличане на подниз

`SUBSTR(текст, начало, дължина)` извлича **част от текста**, започвайки от дадена позиция.

> Позициите в SQL започват от **1** (не от 0 като в Python).

```sql
-- Първите 4 символа от всяко име
SELECT name, SUBSTR(name, 1, 4) AS short_name FROM employees;
```

| name             | short_name |
|------------------|------------|
| Ivan Petrov      | Ivan       |
| Maria Ivanova    | Mari       |
| Georgi Dimitrov  | Geor       |
| ...              | ...        |

---

### 2.4 REPLACE() — Замяна на текст

`REPLACE(текст, стар_текст, нов_текст)` заменя всяко срещане на `стар_текст` с `нов_текст`.

```sql
-- Заменяме "Engineer" с "Dev" в длъжностите
SELECT name, REPLACE(position, 'Engineer', 'Dev') AS new_position FROM employees;
```

| name             | new_position        |
|------------------|---------------------|
| Ivan Petrov      | Software Dev        |
| Maria Ivanova    | Designer            |
| Elena Stoyanova  | QA Dev              |
| Stefan Boev      | DevOps Dev          |
| ...              | ...                 |

---

### 2.5 TRIM() — Премахване на интервали

`TRIM()` премахва **водещите и крайните интервали** от текст. Полезно за почистване на данни.

```sql
SELECT TRIM('   Hello World   ');
-- Резултат: 'Hello World'
```

---

## 3. Математически функции (Math Functions)

---

### 3.1 ROUND() — Закръгляне

`ROUND(число, десетични_знаци)` закръгля число до зададен брой десетични знаци.

```sql
-- Закръгляне на заплатите до цяло число
SELECT name, ROUND(salary, 0) AS salary_rounded FROM employees;
```

| name             | salary_rounded |
|------------------|----------------|
| Ivan Petrov      | 4501.0         |
| Petya Koeva      | 3601.0         |
| ...              | ...            |

```sql
-- Закръгляне до 1 десетичен знак
SELECT name, ROUND(salary, 1) AS salary_rounded FROM employees;
```

> **Забележка:** `ROUND(число)` без втори аргумент закръгля до цяло число.

---

### 3.2 ABS() — Абсолютна стойност

`ABS()` връща **абсолютната стойност** на число (превръща отрицателни числа в положителни).

```sql
SELECT ABS(-4500.50);   -- Резултат: 4500.50
SELECT ABS(4500.50);    -- Резултат: 4500.50
```

Полезно е, когато работите с разлики между числа:

```sql
-- Разлика между заплатата и средната (5000) като абсолютна стойност
SELECT name, ABS(salary - 5000) AS diff_from_avg FROM employees;
```

---

### 3.3 MAX() и MIN() като скаларни функции

Можем да използваме `MAX()` и `MIN()` за да намерим **най-голямата** и **най-малката** стойност в колона:

```sql
SELECT MAX(salary) AS highest_salary FROM employees;
SELECT MIN(salary) AS lowest_salary  FROM employees;
```

| highest_salary |
|----------------|
| 6200.00        |

| lowest_salary |
|---------------|
| 3600.75       |

---

## 4. Функции за Дата и Час (Date/Time Functions)

SQLite използва функцията `strftime()` за форматиране на дати, заедно с `DATE()`, `TIME()` и `DATETIME()`.

---

### 4.1 DATE() — Текуща дата

`DATE('now')` връща **днешната дата** в ISO формат `YYYY-MM-DD`.

```sql
SELECT DATE('now');
-- Примерен резултат: 2026-02-22
```

---

### 4.2 DATETIME() — Текуща дата и час

`DATETIME('now')` връща **текущата дата и час**.

```sql
SELECT DATETIME('now');
-- Примерен резултат: 2026-02-22 14:35:00
```

---

### 4.3 strftime() — Форматиране на дата

`strftime(формат, дата)` ни позволява да извличаме конкретни части от датата.

| Формат | Значение        | Пример (за '2021-03-15') |
|--------|-----------------|--------------------------|
| `%Y`   | Година (4 цифри)| `2021`                   |
| `%m`   | Месец (01-12)   | `03`                     |
| `%d`   | Ден (01-31)     | `15`                     |
| `%H`   | Час (00-23)     | `00`                     |
| `%M`   | Минути (00-59)  | `00`                     |

```sql
-- Извличаме само годината от датата на наемане
SELECT name, strftime('%Y', hire_date) AS hire_year FROM employees;
```

| name             | hire_year |
|------------------|-----------|
| Ivan Petrov      | 2021      |
| Maria Ivanova    | 2020      |
| Georgi Dimitrov  | 2019      |
| Elena Stoyanova  | 2022      |
| Nikolay Todorov  | 2021      |
| Petya Koeva      | 2023      |
| Stefan Boev      | 2020      |

```sql
-- Пълна дата в по-четлив формат: "15.03.2021"
SELECT name, strftime('%d.%m.%Y', hire_date) AS formatted_date FROM employees;
```

---

### 4.4 Смятане на разлика между дати

Можем да изчислим **от колко години работи** даден служител:

```sql
-- Брой години от датата на наемане до днес
SELECT name,
       strftime('%Y', 'now') - strftime('%Y', hire_date) AS years_employed
FROM employees;
```

| name             | years_employed |
|------------------|----------------|
| Ivan Petrov      | 5              |
| Maria Ivanova    | 6              |
| Georgi Dimitrov  | 7              |
| ...              | ...            |

---

## 5. Wildcards — Търсене по шаблон

**Wildcards** (символи-заместители) се използват с ключовата дума `LIKE` и ни позволяват да търсим по **частично съвпадение** на текст.

---

### 5.1 Символът % (процент)

`%` заменя **произволен брой символи** (включително нула символа).

```sql
-- Имена, завършващи на 'ov'
SELECT * FROM employees WHERE name LIKE '%ov';
```

| id | name             | ...  |
|----|------------------|------|
| 1  | Ivan Petrov      | ...  |
| 5  | Nikolay Todorov  | ...  |

```sql
-- Длъжности, съдържащи думата 'Engineer'
SELECT * FROM employees WHERE position LIKE '%Engineer%';
```

| id | name             | position           |
|----|------------------|--------------------|
| 1  | Ivan Petrov      | Software Engineer  |
| 4  | Elena Stoyanova  | QA Engineer        |
| 5  | Nikolay Todorov  | Software Engineer  |
| 7  | Stefan Boev      | DevOps Engineer    |

```sql
-- Имена, започващи с 'M'
SELECT * FROM employees WHERE name LIKE 'M%';
```

---

### 5.2 Символът _ (долна черта)

`_` заменя **точно един символ**.

```sql
-- Имена с точно 4 символа в първата дума (напр. "Ivan")
SELECT * FROM employees WHERE name LIKE 'Ivan _______';
```

```sql
-- Намерете служители, чиято длъжност има точно 8 символа
SELECT * FROM employees WHERE position LIKE '________';
-- Резултат: 'Designer' (8 символа)
```

---

### 5.3 NOT LIKE — Изключване по шаблон

`NOT LIKE` връща редовете, които **НЕ** съвпадат с шаблона.

```sql
-- Всички служители, чиято длъжност НЕ съдържа 'Engineer'
SELECT * FROM employees WHERE position NOT LIKE '%Engineer%';
```

| id | name             | position  |
|----|------------------|-----------|
| 2  | Maria Ivanova    | Designer  |
| 3  | Georgi Dimitrov  | Team Lead |
| 6  | Petya Koeva      | Designer  |

---

### 5.4 Комбиниране на LIKE с AND / OR

Можете да комбинирате `LIKE` с другите условия:

```sql
-- Служители с 'Engineer' в длъжността И заплата над 4500
SELECT name, position, salary
FROM employees
WHERE position LIKE '%Engineer%' AND salary > 4500;
```

---

## Обобщение

| Функция / Ключова дума  | Категория       | Какво прави                                          |
|-------------------------|-----------------|------------------------------------------------------|
| `UPPER(col)`            | Текстова        | Преобразува текст в ГЛАВНИ БУКВИ                     |
| `LOWER(col)`            | Текстова        | Преобразува текст в малки букви                      |
| `LENGTH(col)`           | Текстова        | Връща броя символи в текста                          |
| `SUBSTR(col, n, len)`   | Текстова        | Извлича подниз от позиция `n` с дължина `len`        |
| `REPLACE(col, old, new)`| Текстова        | Замества текст в стойността                          |
| `TRIM(col)`             | Текстова        | Премахва водещи и крайни интервали                   |
| `ROUND(col, n)`         | Математическа   | Закръгля число до `n` десетични знаци                |
| `ABS(col)`              | Математическа   | Абсолютна стойност (без знак)                        |
| `MAX(col)`              | Математическа   | Най-голямата стойност в колона                       |
| `MIN(col)`              | Математическа   | Най-малката стойност в колона                        |
| `DATE('now')`           | Дата/Час        | Текущата дата                                        |
| `DATETIME('now')`       | Дата/Час        | Текуща дата и час                                    |
| `strftime(fmt, col)`    | Дата/Час        | Форматира или извлича части от дата                  |
| `LIKE '%текст%'`        | Wildcard        | Търсение по частично съвпадение                      |
| `LIKE '_текст'`         | Wildcard        | Заместване на точно един символ                      |
| `NOT LIKE`              | Wildcard        | Изключване по шаблон                                 |

---

## Задачи

Използвайте таблицата `employees` от подготовката в началото на лекцията.

---

### Задача 1: Главни букви
Напишете заявка, която извежда имената на **всички служители** с **главни букви**. Наименувайте колоната `IME`.

*(Подсказка: `UPPER(name) AS IME`)*

---

### Задача 2: Дължина на длъжностите
Напишете заявка, която извежда `name`, `position` и дължината на длъжността (в символи) като трета колона с наименование `position_length`.
Наредете резултата по дължина — от най-дългата до най-кратката длъжност.

---

### Задача 3: Закръгляне на заплати
Напишете заявка, която показва `name` и заплатата, **закръглена до 0 десетични знаци**, като колоната се казва `salary_rounded`.

---

### Задача 4: Най-ниска и най-висока заплата
Напишете **две отделни заявки**:
- Едната да върне **най-ниската** заплата в таблицата.
- Другата да върне **най-високата** заплата в таблицата.

---

### Задача 5: Година на наемане
Напишете заявка, която извежда `name` и **само годината** от `hire_date`, като я наречете `hire_year`.
Наредете резултата от **най-стария** към **най-новия** служител.

---

### Задача 6: Служители, наети след 2021
Напишете заявка, която връща всички служители, наети **след** 2021 година (т.е. от 2022 нагоре).

*(Подсказка: `strftime('%Y', hire_date) >= '2022'`)*

---

### Задача 7: Wildcard — Имена, завършващи на 'ova'
Напишете заявка, която връща всички служители, чието **фамилно или собствено** ime **завършва на `'ova'`**.

*(Подсказка: `name LIKE '%ova'`)*

---

### Задача 8: Wildcard — Длъжности, съдържащи 'Engineer'
Напишете заявка, която връща `name` и `salary` на всички служители, чиято **длъжност съдържа думата `'Engineer'`**.
Наредете ги по **заплата низходящо**.

---

### Задача 9: Комбинирана заявка
Напишете заявка, която извежда:
- `name` с **главни букви** (като `NAME`)
- `position`
- `salary` **закръглена** до цяло число (като `salary_rounded`)

... само за служителите, чиято длъжност **съдържа `'Engineer'`** ИЛИ чиято заплата е **над 6000**.

---

### Задача 10: Форматирана дата и години трудов стаж
Напишете заявка, която извежда:
- `name`
- `hire_date` форматирана като `'DD.MM.YYYY'` (като `formatted_date`)
- Броят **пълни години** от наемането до днес (като `years_employed`)

Наредете резултата от **най-дългия стаж** към **най-краткия**.

---

*Следваща лекция: агрегатни функции (`COUNT`, `SUM`, `AVG`) и групиране на данни с `GROUP BY` и `HAVING`.*
